from datetime import datetime
from HandleCsv import HandleCSV
import csv
import os

class sell:
    def __init__(self, handle_date_instance, csv_handler):
        self.handle_date = handle_date_instance
        self.csv_handler = csv_handler

    def check_stock(self, product_name, quantity, expiration_date):
        inventory_data = self.csv_handler.read()
        available_quantity = sum(
            int(row["Quantity"])
            for row in inventory_data
            if row["Product_name"] == product_name and row["Type"] == "Buy" and row["Expiration_date"] == expiration_date
        )

        if available_quantity < quantity:
            print(f"Error: Product '{product_name}' is not in stock.")
            return False

        return True
    

    def write(self, product_name, quantity, price):
        if not self.csv_handler:
            return

        data = self.csv_handler.read()

        # Zoek naar "buy" producten met dezelfde naam als het verkochte product en sorteer ze op vervaldatum
        matching_buys = [row for row in data 
                         if row["Type"] == "Buy" 
                         and row["Product_name"] == product_name 
                         and row.get("Status") != "Not active"
                         ]
        matching_buys = sorted(matching_buys, key=lambda x: datetime.strptime(x["Expiration_date"], "%Y-%m-%d"))

        if not matching_buys:
            print(f"Error: No inventory found for '{product_name}'.")
            return

        current_date = self.handle_date.read()

        # Filter "buy" producten met een toekomstige vervaldatum
        future_expirations = [buy for buy in matching_buys if datetime.strptime(buy["Expiration_date"], "%Y-%m-%d") >= current_date]

        if not future_expirations:
            print(f"Error: All available products for '{product_name}' have expired.")
            return

        # Controleer of er voldoende voorraad is om te verkopen
        remaining_quantity = quantity
        for buy in future_expirations:
            if remaining_quantity <= 0:
                break

            buy_quantity = int(buy["Quantity"])
            if buy_quantity >= remaining_quantity:
                # De "buy" heeft genoeg voorraad om de resterende hoeveelheid te dekken
                buy["Quantity"] = str(buy_quantity - remaining_quantity)
                remaining_quantity = 0
            else:
                # De "buy" heeft niet genoeg voorraad, dus verkopen wat er beschikbaar is en doorgaan naar de volgende
                remaining_quantity -= buy_quantity
                buy["Quantity"] = "0"

        if remaining_quantity > 0:
            print("Error: Selling more than the available quantity is not possible.")
            return

        # Voeg een nieuwe "sell" record toe
        data_row = {
            "Type": "Sell",
            "Product_name": product_name,
            "Quantity": quantity,
            "Price": price,
            "Date": current_date.strftime("%Y-%m-%d"),
            "Expiration_date": future_expirations[0]["Expiration_date"]
        }
        data.append(data_row)  # Voeg de nieuwe "sell" record toe aan de lijst

        # Werk de CSV bij met de gewijzigde "buy" records
        for buy in future_expirations:
            if int(buy["Quantity"]) <= 0:
        # Pas de status van "buy" records met een hoeveelheid van 0 aan naar "SOLD"
                buy["Status"] = "Sold"
            else:
                buy["Quantity"] = str(max(0, int(buy["Quantity"]) - remaining_quantity))


        self.csv_handler.write_all(data)  # Schrijf alle records naar de CSV
        print(f"Sale recorded for product '{product_name}'.")

    def complete_sell(self, product_name, quantity, price):
        # Voer de verkooptransactie uit
        data = self.csv_handler.read()

        # Controleer of het product in de voorraad is en niet "Sold"
        matching_buys = [row for row in data 
                        if row["Type"] == "Buy" 
                        and row["Product_name"] == product_name 
                        and row["Status"] != "Sold"
                        ]
        matching_buys = sorted(matching_buys, key=lambda x: datetime.strptime(x["Expiration_date"], "%Y-%m-%d"))

        if not matching_buys:
            print(f"Error: No matching 'Buy' records found for '{product_name}' or all matching records are 'Sold'.")
            return

        # Selecteer het "Buy" record met de oudste vervaldatum
        oldest_buy = matching_buys[0]

        # Controleer of er genoeg voorraad is om te verkopen
        available_quantity = int(oldest_buy["Quantity"])
        if available_quantity < quantity:
            print(f"Error: Selling more than the available quantity is not possible.")
            return

        # Onthoud de oorspronkelijke hoeveelheid voor latere herstel
        original_quantity = available_quantity

        # Verlaag het aantal in het oudste "Buy" record
        oldest_buy["Quantity"] = str(available_quantity - quantity)

        # Als de voorraad uitverkocht is, wijzig de status naar 'Sold'
        if int(oldest_buy["Quantity"]) == 0:
            oldest_buy["Status"] = "Sold"

        # Voeg een nieuw "Sell" record toe
        current_date = self.handle_date.read()
        expiration_date = oldest_buy["Expiration_date"]
        data_row = {
            "Type": "Sell",
            "Product_name": product_name,
            "Quantity": quantity,
            "Price": price,
            "Date": current_date.strftime("%Y-%m-%d"),
            "Expiration_date": expiration_date
        }
        data.append(data_row)

        # Herstel de oorspronkelijke hoeveelheid als de status 'Sold' is
        if oldest_buy["Status"] == "Sold":
            oldest_buy["Quantity"] = str(original_quantity)

        self.csv_handler.write_all(data)
        print(f"Sale recorded for product '{product_name}'.")

        

'''
    def complete_sell(self, product_name, quantity, price):
        # Voer de verkooptransactie uit
        data = self.csv_handler.read()

        # Zoek naar "Buy" records met dezelfde productnaam en sorteer ze op vervaldatum (oudste eerst)
        matching_buys = [row for row in data 
                        if row["Type"] == "Buy" 
                        and row["Product_name"] == product_name 
                        and row["Status"] != "Not active"
                        ]
        matching_buys = sorted(matching_buys, key=lambda x: datetime.strptime(x["Expiration_date"], "%Y-%m-%d"))

        if not matching_buys:
            print(f"Error: No matching 'Buy' records found for '{product_name}'.")
            return

        # Selecteer het "Buy" record met de oudste vervaldatum
        oldest_buy = matching_buys[0]

        # Controleer of er genoeg voorraad is om te verkopen
        available_quantity = int(oldest_buy["Quantity"])
        if available_quantity < quantity:
            print(f"Error: Selling more than the available quantity is not possible.")
            return

        # Verlaag het aantal in het oudste "Buy" record
        oldest_buy["Quantity"] = str(available_quantity - quantity)

        # Als de voorraad uitverkocht is, wijzig de status naar 'Sold'
        if int(oldest_buy["Quantity"]) == 0:
            oldest_buy["Status"] = "Sold"

        # Voeg een nieuw "Sell" record toe
        current_date = self.handle_date.read()
        expiration_date = oldest_buy["Expiration_date"]
        data_row = {
            "Type": "Sell",
            "Product_name": product_name,
            "Quantity": quantity,
            "Price": price,
            "Date": current_date.strftime("%Y-%m-%d"),
            "Expiration_date": expiration_date
        }
        data.append(data_row)

        self.csv_handler.write_all(data)
        print(f"Sale recorded for product '{product_name}'.")

'''
